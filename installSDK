#!/usr/bin/swift

import Foundation

extension String {
    var lastPathComponent: String {
        get {
            return (self as NSString).lastPathComponent
        }
    }
    var pathExtension: String {
        get {
            return (self as NSString).pathExtension
        }
    }
    var stringByDeletingLastPathComponent: String {
        get {
            return (self as NSString).deletingLastPathComponent
        }
    }
    var stringByDeletingPathExtension: String {
        get {
            return (self as NSString).deletingPathExtension
        }
    }
    var pathComponents: [String] {
        get {
            return (self as NSString).pathComponents
        }
    }
    func stringByAppendingPathComponent(path: String) -> String {
        let nsSt = self as NSString
        return nsSt.appendingPathComponent(path)
    }
    func stringByAppendingPathExtension(ext: String) -> String? {
        let nsSt = self as NSString
        return nsSt.appendingPathExtension(ext)
    }
    func appendingPathComponent(_ path: String) -> String {
        return (self as NSString).appendingPathComponent(path)
    }
    var deletingPathExtension : String {
        get {
            (self as NSString).deletingPathExtension
        }
    }
    
    func matchesForRegex(_ regex: String) -> [String] {
      var result = [String]()
      do {
        let regex = try NSRegularExpression(pattern: regex, options: [])
        let nsString = self as NSString
        if let match = regex.firstMatch(in: self, options: [], range: NSMakeRange(0, nsString.length)) {
          for i in 1..<match.numberOfRanges {
            result.append(nsString.substring(with: match.range(at: i)))
          }
        }
      } catch let error as NSError {
        print("invalid regex: \(error.localizedDescription)")
      }
      return result
    }
}

@discardableResult func shell(_ command: String) -> (String?, Int32) {
    let task = Process()

    task.launchPath = "/bin/bash"
    task.arguments = ["-c", command]

    let pipe = Pipe()
    task.standardOutput = pipe
    task.standardError = pipe
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)
    task.waitUntilExit()
    return (output, task.terminationStatus)
}

// check command line arguments
if CommandLine.arguments.count != 2 {
    print("Usage: \(CommandLine.arguments[0].lastPathComponent) Rainbow_SDK_framework")
    exit(1)
}

let newSDKFramework =  CommandLine.arguments[1]

let directories = [
	"Rainbow-iOS-SDK-Sample-Background",
	"Rainbow-iOS-SDK-Sample-Channels",
	"Rainbow-iOS-SDK-Sample-Contacts",
	"Rainbow-iOS-SDK-Sample-FileSharing",
	"Rainbow-iOS-SDK-Sample-IM",
	"Rainbow-iOS-SDK-Sample-Login",
	"Rainbow-iOS-SDK-Sample-SFU",
	"Rainbow-iOS-SDK-Sample-Swift",
	"Rainbow-iOS-SDK-Sample-WebRTC"
]


for dir in directories {
    print("\(String(repeating: "*", count: 60))")
    print("Installing SDK in: \(dir)")
    print("\(String(repeating: "*", count: 60))")
 

    let (xcodeprojFile, _) = shell("cd \(dir);  ls -d *.xcodeproj")
    if let xcodeprojFile = xcodeprojFile {
        let xcodeprojFile = xcodeprojFile.trimmingCharacters(in: .whitespacesAndNewlines)
        let projDir = xcodeprojFile.deletingPathExtension
        print ("XCode project dir : \(projDir)")

        let sdkFramework = dir.stringByAppendingPathComponent(path:"\(projDir)/Carthage/Build/iOS/Rainbow.framework")   
 
	if FileManager.default.fileExists(atPath: sdkFramework){  
           print("Removing \(sdkFramework) ...\n")
           shell("rm -rf \(sdkFramework)")
	}        

        print("Copying new SDK...")
        let (output, retCode) = shell("cp -a \(newSDKFramework) \(sdkFramework)")
        print("Return code=\(retCode)")
	if let output = output {
	   print(output)
	}
    }
    print("\n")
}




